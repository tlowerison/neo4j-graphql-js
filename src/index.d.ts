import { Context } from './dynamic-auth';
import { Driver } from 'neo4j-driver';
import { ExecutionResult, GraphQLResolveInfo, GraphQLSchema } from 'graphql';
import { IExecutableSchemaDefinition } from 'apollo-server-express';

export * from './dynamic-auth';

type Config = {
  auth?: {
    /**
     * GraphQL enum type name containing role names
     * - if you'd like to allow any value as a role, use roleType: 'String'
     * - defaults to 'Role'
     */
    roleType?: string;
    /**
     * GraphQL enum type name containing scope names
     * - if you'd like to allow any value as a scope, use scopeType: 'String'
     * - defaults to 'Scope'
     */
    scopeType?: string;
    /**
     * Contains authorization directive definitions living in .auth files
     */
    typeDefs?: string;
  };
  /**
   * Enable/disable logging of generated Cypher queries and parameters
   */
  debug?: boolean;
  /**
   * Configure the autogenerated Query fields
   * - can be enabled/disabled for all types or a list of individual types to exclude can be passed
   * - commonly used to exclude payload types
   */
  query?: boolean | {
    exclude: string[];
  };
  /**
   * Configure the autogenerated Mutation fields
   * - can be enabled/disabled for all types or a list of individual types to exclude can be passed
   * - commonly used to exclude payload types
   */
  mutation?: boolean | {
    exclude: string[];
  };
};

/**
 * Wraps makeExecutableSchema to create a GraphQL schema from GraphQL type definitions (SDL). Will generate Query
 * and Mutation types for the provided type definitions and attach neo4jgraphql as the resolver for these queries
 * and mutations. Either a schema or typeDefs must be provided. resolvers can optionally be implemented to override
 * any of the generated Query/Mutation fields. Additional options are passed through to makeExecutableSchema.
 */
export declare function makeAugmentedSchema<TContext extends Context>(
  options: IExecutableSchemaDefinition<TContext> & { config: Config },
): GraphQLSchema;

/**
 * This function uses the @id, @unique, and @index schema directives present in the GraphQL type definitions to add
 * any database constraints and indexes.
 */
export declare function assertSchema(options: {
  schema: GraphQLSchema;
  driver: Driver;
  debug?: boolean;
  dropExisting?: boolean;
}): null;

/**
 * This function's signature matches that of GraphQL resolver functions and thus the parameters match the parameters
 * passed into resolve by GraphQL implementations like graphql-js. It can be called within a resolver to generate a
 * Cypher query and handle the database call to Neo4j to completely resolve the GraphQL request. Alternatively, use
 * cypherQuery or cypherMutation within a resolver to only generate the Cypher query and handle the database call yourself.
 */
export declare function neo4jgraphql<
  TSource,
  TContext extends Context,
  TArgs = { [argName: string]: any },
  TData = { [key: string]: any },
  TExtensions = { [key: string]: any },
>(
  source: TSource,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
  debugFlag?: boolean,
): ExecutionResult<TData, TExtensions>;

/**
 * Takes an existing GraphQL schema object and adds neo4j-graphql-js specific enhancements, including auto-generated
 * mutations and queries, and ordering and pagination fields. See this guide for more information.
 * Only use augmentSchema if you are working with an existing GraphQLSchema object. In most cases you should use
 * makeAugmentedSchema which can construct the GraphQLSchema object from type definitions.
 */
export declare function augmentSchema({ config: Config }): GraphQLSchema;

/**
 * Generates a Cypher query (and associated parameters) to resolve a given GraphQL request (for a Query). Use this
 * function when you want to handle the database call yourself, use neo4jgraphql for automated database call support.
 */
export declare function cypherQuery<
  TContext extends Context,
  TArgs = { [argName: string]: any }
>(
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
): [string, Record<string, any>];

/**
 * Similar to cypherQuery, but for mutations. Generates a Cypher query (and associated parameters) to resolve a
 * given GraphQL request (for a Mutation). Use this function when you want to handle the database call yourself,
 * use neo4jgraphql for automated database call support.
 */
export declare function cypherMutation<
  TContext extends Context,
  TArgs = { [argName: string]: any }
>(
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
): [string, Record<string, any>];

/**
 * Used to generate GraphQL type definitions from an existing Neo4j database by inspecting the data stored in the
 * database. When used in combination with makeAugmentedSchema this can be used to generate a GraphQL CRUD API on
 * top of an existing Neo4j database without writing any resolvers or GraphQL type definitions.
 */
export declare function inferSchema(driver: Driver, options?: { alwaysIncludeRelationships?: boolean }): Promise<{
  typeDefs: string;
}>;

/**
 * Given a glob pattern, return the result of concatenating all the contents of the matched files.
 */
export declare function readFiles(pattern: string): string;

export declare function wrapNeo4jgraphql<
  T,
  V,
  TSource,
  TContext extends Context,
  VSource,
  VContext extends Context,
  TArgs = { [argName: string]: any },
  VArgs = { [argName: string]: any },
>(
  transformArgs: (args: Required<Args<TSource, TContext, TArgs>>) => PromiseOrNot<Args<VSource, VContext, VArgs> & ReturnArgs<T, V>>,
): (
  source: TSource,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
  debugFlag?: boolean,
) => V;

type Args<
  TSource,
  TContext extends Context,
  TArgs = { [argName: string]: any },
> = {
  source?: TSource;
  args?: TArgs;
  context?: TContext;
  info?: GraphQLResolveInfo;
};

type ReturnArgs<T = any, V = any> = {
  debugFlag?: boolean;
  result?: (value: T) => V;
};

type PromiseOrNot<T> = T | Promise<T>;
